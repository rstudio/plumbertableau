---
title: "Writing plumbertableau Extensions in R"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Writing plumbertableau Extensions in R}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)

# Load package
library(plumbertableau)

# Set random seed
set.seed(35487)

# R chunks
knitr::read_chunk(path = system.file("plumber", "loess", "plumber.R", package = "plumbertableau"),
                  labels = "loess")
```



## Getting started {#getting-started}

This vignette will walk you through writing plumbertableau extensions in R. plumbertableau extensions are Plumber web services with a few additional pieces, and this vignette assumes some familiarity with Plumber (https://www.rplumber.io/). Plumber's [Quickstart guide](https://www.rplumber.io/articles/quickstart.html) gives a good overview of that package. Throughout this guide we'll use the terms "web service" and "API" (application programming interface) interchangeably.

You can install the plumbertableau package from CRAN or GitHub.

```{r, eval = FALSE}
# from CRAN
install.packages("plumbertableau")

# from GitHub
remotes::install_github("rstudio/plumbertableau")
```

## What can plumbertableau extensions do? {#capabilities}

plumbertableau extensions respond to requests from Tableau. In a request, Tableau will provide an [*endpoint*](https://www.rplumber.io/articles/routing-and-input.html?q=endpoint#endpoints-1) — which roughly corresponds to an R function — and will send along one or more *arguments*, which will generally consist of data from Tableau.

An extension **must** return data that's the same elements or rows as the arguments it receive. It can do things like transform text, or use a model to predict Y values from a matrix of X values. It can't, say, receive an integer representing the number of elements to sample, and return a vector of that length.

## An example with loess regression

Let's start with some plain R code that uses the `loess()` function to fit a smooth line across some input data and plot the result.

```{r fig.width=6.5, fig.height=4.5}
x <- seq(1, 10, length.out = 100)
y <- 1/x^2 + rnorm(length(x), sd = 0.05)
fit <- loess(y ~ x, span = 0.75)
y_fit <- predict(fit, data.frame(x, y))

# Plot the data and prediction.
plot(x, y)
lines(x, y_fit)
```

## The anatomy of a plumbertableau extension {#anatomy}

Here's that same model in a finished plumbertableau extension.

```{r loess, eval = FALSE}
```

There are a few parts to our extension which are required to make it work:

- **Annotations**. Comments beginning with `#*` are [annotations](https://www.rplumber.io/articles/annotations.html), which define aspects of the API for Plumber and plumbertableau.
- **Function definitions** — Each function definition must use annotations to describe the data types for all inputs and the value it returns.
- **The Tableau extension footer** — This contains the `tableau_extension` object with the `@plumber` annotation. This does the work of modifying the Plumber router to be Tableau-compatible.

## Annotating function definitions for Tableau

Let's look again at our un-annotated function definition.

```{r, eval = FALSE}
#* Annotate me!
function(x, y, alpha = 0.75) {
  alpha <- as.numeric(alpha)
  l_out <- loess(y ~ x, span = alpha)
  predict(l_out, data.frame(x, y))
}
```

It accepts three inputs: `x`, `y`, and `alpha`. It fits a `loess()` model using this data, and returns the output of the `predict()` function for that model. We need to annotate its inputs and output so that plumbertableau can translate the data correctly for Tableau.

**Data provided by Tableau** is described using the `@tab.arg` annotation. These annotations require a name and a type, and can optionally contain a description: `#* @tab.arg Name:Type Description`. In our example:

```{r, eval=FALSE}
#* @tab.arg x:integer X values for fitting
#* @tab.arg y:numeric Y values for fitting
```

Here, `x:integer` specifies the `x` argument by name, and tells plumbertableau to expect an integer vector. The string `X values for fitting` will be used to describe this argument in the generated API documentation.

**Data returned to Tableau** is described with `@tab.return`. The syntax is similar to `@tab.arg`, without an argument name: `#* @tab.return Type Description`.

```{r, eval=FALSE}
#* @tab.return numeric Fitted loess values
```

plumbertableau will expect `numeric` data to be returned, and will describe it as `Fitted loess values` in our documentation.

**URL parameters** are arguments described with Plumber's [`@param`](https://www.rplumber.io/articles/annotations.html#endpoint) annotation. These are useful for providing fixed values that don't use data from Tableau objects. In our example the optional `alpha` parameter lets Tableau users control the degree of smoothing used in the `loess` model.

```{r, eval=FALSE}
#* @param alpha Degree of smoothing
```

Tableau users can now add `?alpha=0.5` to the end of the extension URL to control the degree of smoothing.

### Data types



## Tableau extension footer

```{r, eval = FALSE}
#* @plumber
tableau_extension
```

In order for this API to properly respond to Tableau requests, using `tableau_extension` is required. This function handles the request from Tableau and makes sure it's forwarded to the correct endpoint.

## Testing {#testing}

Once the extension has been developed, it can be tested locally through the default Swagger UI. In RStudio, you can click the Run API button, or you can use `plumber::plumb()$run()` to run the API. Once the API is running, you'll be presented with an interface like the following:

![Swagger UI](files/swagger.png){width=75%}

From this page, you can click on the `/predict` endpoint to expand the available options. You can then click "Try it out" to test the API.

![Swagger Predict](files/swagger-predict.png){width=75%}

Tableau requests contain a JSON request body that contains two objects^[[Tableau Analytics Extensions API Reference](https://tableau.github.io/analytics-extensions-api/docs/ae_api_ref.html#post-evaluate)].
* script: In the case of `plumbertableau`, this is a string that identifies the specific endpoint being requested.
* data: This object contains the data being passed from Tableau to the extension. In the case of `plumbertableau`, this data is parsed and automatically made available to the underlying function. Note that values passed from Tableau are unnamed, and instead follow the naming convention `_arg1`, `_arg2`, ... ,`_argN`.

`plumbertableau` automatically provides a simple mock request that follows the specification provided by Tableau. This initial mock request contains simple `script` and `data` values. If you'd like, you can use `tableau_json()` to create a more full-featured request for use with Swagger:

```{r}
tableau_json(script = "/predict", 
             data = mtcars[,c("hp", "mpg")])
```

Note that you will have to stop the running API in order to generate the mock request body in the current R session.

Once you've generated a mock request body, you can insert it into the Swagger documentation for the API to test the API.

![Swagger testing](files/swagger-test.png){width=75%}

### Deploying {#deploying}

`plumbertableau` is designed to be used with RStudio Connect. RStudio Connect supports a variety of [different deployment methods](https://docs.rstudio.com/connect/user/publishing/). Once an extension is published to RStudio Connect, a few things need to be adjusted to make it easily accessible from Tableau.

1. Provide proper access
Tableau extensions used from Tableau Server and Tableau Online are setup with a single set of shared credentials. We recommend creating a service account on RStudio Connect and using that account to manage access to extensions. For example, if the service account username is "Tableau", you would give the "Tableau" user access to the extension after it's been published.

2. Assign a vanity URL
By default, content published to RStudio Connect is assigned a URL containing the content GUID. These urls are long and unindicative of what the actual content is. We strongly recommend assigning a vanity URL to each extension published to RStudio Connect. This allows the extension to be easily referenced from Tableau workbooks. For example, if we published the previous example extension to RStudio Connect and assigned the vanity URL `/loess`, we would refer to it from a calculated field in Tableau with `/loess/predict`.

#### Compatability
Tableau Analytics Extensions are only supported in RStudio Connect version 1.9+. If you publish an extension to an unsupported version of RStudio Connect, the extension will successfully publish but then you will see the following message when visiting the extension:

![Warning message](files/warnings.png){width=75%}

Additionally, Tableau Analytics Extensions have the following requirements on RStudio Connect:
* `Tableau.IntegrationEnabled` must be `TRUE` - this is the default, but can be turned off by an RStudio Connect administrator
* `Connect.ServerAddress` must be set

If either of these criteria are not met, a published extension will show a warning message similar to the one above.

### Debugging {#debugging}
Logging can be enabled for `plumbertableau` using [`debugme`](https://github.com/r-lib/debugme). Setting the `DEBUGME` environment variable to a value containing `plumbertableau` prior to loading the package will result in additional logging to the R console. These log messages can be helpful in understanding what's happening with each request, as well as what is contained in each request. This feature is also available for content deployed on RStudio Connect by adding the `DEBUGME` [environment variable](https://docs.rstudio.com/connect/user/content-settings/#content-vars).
RStudio Connect administrators can enable additional logging for Tableau extensions hosted on RStudio Connect.

Adding `browser()` statements during local development can also aid in debugging efforts.
